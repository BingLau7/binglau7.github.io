<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="锁介绍下面锁的实现逻辑  synchronized ReentranLock ReentranReadWriteLock StampedLock">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发基础-锁">
<meta property="og:url" content="http://example.com/2025/05/25/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E9%94%81/index.html">
<meta property="og:site_name" content="村里最好的博客">
<meta property="og:description" content="锁介绍下面锁的实现逻辑  synchronized ReentranLock ReentranReadWriteLock StampedLock">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/images/java/concurrency-lock-1.png">
<meta property="article:published_time" content="2025-05-25T09:58:46.000Z">
<meta property="article:modified_time" content="2025-05-25T10:24:57.807Z">
<meta property="article:author" content="刘冰鉴">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/java/concurrency-lock-1.png">


<link rel="canonical" href="http://example.com/2025/05/25/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E9%94%81/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"http://example.com/2025/05/25/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E9%94%81/","path":"2025/05/25/Java并发基础-锁/","title":"Java并发基础-锁"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java并发基础-锁 | 村里最好的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">村里最好的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">1.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-AbstractQueuedSynchronizer"><span class="nav-number">1.1.</span> <span class="nav-text">AQS(AbstractQueuedSynchronizer)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.1.</span> <span class="nav-text">关键方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.2.</span> <span class="nav-text">核心设计原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.3.</span> <span class="nav-text">典型使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E6%94%B6%E8%8E%B7"><span class="nav-number">1.1.4.</span> <span class="nav-text">学习收获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CHL-%E9%94%81%E8%AF%B4%E6%98%8E%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.5.</span> <span class="nav-text">CHL 锁说明介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">synchronized 的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Monitor-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.1.</span> <span class="nav-text">Monitor 对象的介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.</span> <span class="nav-text">ReentrantLock 的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.</span> <span class="nav-text">关键实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantReadWriteLock-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.</span> <span class="nav-text">ReentrantReadWriteLock 的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StampedLock-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.</span> <span class="nav-text">StampedLock 的实现****</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-number">2.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘冰鉴</p>
  <div class="site-description" itemprop="description">Res severa est verum gaudium.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/25/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘冰鉴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
      <meta itemprop="description" content="Res severa est verum gaudium.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java并发基础-锁 | 村里最好的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发基础-锁
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-05-25 17:58:46 / Modified: 18:24:57" itemprop="dateCreated datePublished" datetime="2025-05-25T17:58:46+08:00">2025-05-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>介绍下面锁的实现逻辑</p>
<ul>
<li>synchronized</li>
<li>ReentranLock</li>
<li>ReentranReadWriteLock</li>
<li>StampedLock</li>
</ul>
<span id="more"></span>

<h3 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS(AbstractQueuedSynchronizer)"></a>AQS(<code>AbstractQueuedSynchronizer</code>)</h3><p>锁（ReentranLock）的基础类实现，也是很多并发工具类的基础类依赖（比如 Semaphore, CountDownLatch）。</p>
<p>通过一个 <code>int state</code> 成员变量表示同步状态（如锁的持有次数），并通过内置的 <strong>FIFO 队列 管理等待获取资源的线程</strong>，从而实现<strong>多线程对共享资源的有序访问</strong>。</p>
<h4 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h4><ol>
<li><strong>状态管理方法</strong></li>
</ol>
<p>**<code>tryAcquire(int arg)</code>**：独占式尝试获取同步状态。需要子类实现，若成功返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>**<code>**tryRelease(int arg)</code><strong>：</strong>独占式释放同步状态。子类实现。成功返回 <code>true</code>否则 <code>false</code></p>
<p>**<code>**tryAcquireShared(int args)</code><strong>：</strong>共享式尝试获取同步状态。子类实现，返回值表示剩余可用资源，负数失败，0&#x2F;正数成功。</p>
<p>**<code>**tryReleaseShared(int args)</code><strong>：</strong>共享式释放状态。子类实现。</p>
<ol start="2">
<li><strong>模板方法</strong></li>
</ol>
<p><strong><code>acquire(int arg)</code><strong>：独占式获取同步状态。调用 <code>tryAcquire</code>尝试获取，失败则将线程加入等待队列并</strong>自旋</strong>，直到前驱节点为头节点且成功获取资源。</p>
<p>**<code>release(int arg)</code>**：独占式释放同步状态。调用 <code>tryRelease</code>释放后，唤醒后继节点的线程。</p>
<p>**<code>acquireShared(int arg)</code>**：共享式获取同步状态。调用 <code>tryAcquiredShared</code>成功后，传播唤醒后续节点。</p>
<p>**<code>releaseShared(int arg)</code>**：共享式释放同步状态。调用 <code>tryReleaseShared</code>后，唤醒后续等待的线程。</p>
<ol start="3">
<li><strong>条件队列管理</strong></li>
</ol>
<p>**<code>newCondition()</code>**：创建与 AQS 实例绑定的 <code>Condition</code>对象，用于实现线程等待&#x2F;通知机制（如 <code>await()</code>和 <code>signal()</code>）</p>
<ol start="4">
<li><strong>辅助方法</strong></li>
</ol>
<p>**<code>isHeldExclusively()</code>**：判断当前同步状态是否被独占（如 ReentranLock 中检测锁持有线程是否为当前线程）</p>
<p>**<code>acquireInterruptibly(int arg)</code>**：可中断的获取同步状态。在自旋过程中若检测到线程中断，直接抛出异常并退出。</p>
<h4 id="核心设计原理"><a href="#核心设计原理" class="headerlink" title="核心设计原理"></a>核心设计原理</h4><ul>
<li>**同步状态管理 **：通过 <strong><code>volatile int state</code></strong> 变量表示状态，依赖 CAS 操作保证原子性（如 <code>**&gt;compareAndSetState**</code>）</li>
<li>**队列同步 **：维护一个双向 FIFO 队列（CLH 队列变体），将未获取资源的线程封装为节点（Node）并阻塞，前驱节点释放后唤醒后继节点 </li>
<li>**子类扩展 **：子类通过实现 <strong><code>tryAcquire/tryRelease</code></strong> 等方法定义同步逻辑，AQS 负责底层线程阻塞、唤醒及队列管理</li>
</ul>
<h4 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h4><ul>
<li>**独占锁 **：如 **<code>ReentrantLock</code>**，通过 <strong><code>tryAcquire</code></strong> 和 <strong><code>tryRelease</code></strong> 实现可重入锁逻辑。</li>
<li>**共享锁 **：如 <strong><code>Semaphore</code></strong> 和 **<code>CountDownLatch</code>**，通过 <strong><code>tryAcquireShared</code></strong> 和 <strong><code>tryReleaseShared</code></strong> 控制资源访问。</li>
<li>**条件变量 **：结合 <strong><code>Condition</code></strong> 实现线程间的精确等待与通知</li>
</ul>
<h4 id="学习收获"><a href="#学习收获" class="headerlink" title="学习收获"></a>学习收获</h4><ol>
<li>AQS 明显使用了<strong>模板方法</strong>的模式，在确定使用用途的时候，通过固定的代码框架可以避免代码的重复性。但是需要对后续实现功能有比较确切的了解才能使用，否则后续容易导致子类变更影响的扩散。</li>
<li><code>volatile int state</code>+ CAS 的操作以<strong>无锁化</strong>的方式实现了线程安全。</li>
<li>AQS 内部维护了一个基于 <strong>CLH 锁</strong>（基于单向链表的高性能、公平的自旋锁，核心是将竞争锁的线程组织称一个隐式的队列，每个线程仅在本地变量上自旋，通过轮询前驱节点的状态来判断是否可以获取锁）变体的 FIFO 同步队列，用于管理等待获取资源的线程，其中关键技巧：<ol>
<li>节点自旋与阻塞 ：等待线程通过自旋检查前驱节点状态，减少不必要的线程唤醒开销；若长时间未获取资源，则调用 LockSupport.park 阻塞线程 </li>
<li>传播唤醒机制 ：在共享模式下（如 releaseShared），唤醒后继节点的同时可能继续传播唤醒后续节点，避免线程饥饿</li>
</ol>
</li>
<li>条件变量与多路通知。AQS 提供的 <strong>Condition 接口支持线程等待&#x2F;通知机制</strong>，允许线程在特定条件下释放锁并进入等待队列，待条件满足后被唤醒 。其设计体现了：<ol>
<li>分离等待队列 ：每个 Condition 维护独立的等待队列，避免多线程竞争导致的唤醒冲突。</li>
<li>精确唤醒 ：通过 signal 和 signalAll 可选择性地唤醒等待线程，而非盲目通知所有线程</li>
</ol>
</li>
</ol>
<h4 id="CHL-锁说明介绍"><a href="#CHL-锁说明介绍" class="headerlink" title="CHL 锁说明介绍"></a>CHL 锁说明介绍</h4><blockquote>
<ol>
<li>单机多核系统的线程同步（AQS）</li>
<li>需要公平性保证的场景</li>
<li>地空间复杂度需求：CLH 锁空间复杂度是 O(L+n) (L 是锁数量，n 是线程数)</li>
</ol>
<p>相较于传统操作系统的互斥锁（Mutex）通过自旋减少上下文切换的开销，适合低延迟的场景。</p>
<p>Java 中的 synchronized 是基于 CPU 指令(monitor 对象)实现的，而 ReentrantLock 基于 AQS 实现的。</p>
<p><strong>CLH 锁实现原理简单概述？</strong></p>
<p>线程通过自旋检查前驱节点状态来决定是否获取锁。其核心原理是：</p>
<ol>
<li>**队列结构 **：线程竞争锁时，会以 FIFO（先进先出）顺序加入链表队列，每个节点仅需关注前驱节点 </li>
<li>**自旋机制 **：线程在未获取锁时持续自旋检查前驱节点的状态，当前驱节点释放锁后，当前线程才能尝试获取锁 </li>
<li>**公平性 **：保证线程按申请顺序获取锁，避免饥饿问题</li>
<li>**无锁化操作 **：通过 CAS 原子操作维护队列，减少锁竞争</li>
</ol>
<p><strong>实现原理描述</strong></p>
<p>数据结构定义</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLHNode</span>:</span><br><span class="line">    prev: CLHNode  <span class="comment">// 前驱节点</span></span><br><span class="line">    next: CLHNode  <span class="comment">// 后继节点</span></span><br><span class="line">    status: Boolean  <span class="comment">// 状态（是否持有锁）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLHLock</span>:</span><br><span class="line">    tail: CLHNode  <span class="comment">// 尾指针，指向队列最后一个节点</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>lock 方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">lock</span><span class="params">()</span>:</span><br><span class="line">    node = <span class="keyword">new</span> <span class="title class_">CLHNode</span>()</span><br><span class="line">    node.status = <span class="literal">false</span>  <span class="comment">// 初始状态为未持有锁</span></span><br><span class="line">    prev_node = CASExchange(tail, node)  <span class="comment">// 原子操作：将当前节点插入队列尾部</span></span><br><span class="line">    <span class="keyword">if</span> prev_node == <span class="literal">null</span>:</span><br><span class="line">        <span class="comment">// 队列为空，当前线程直接获取锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node.prev = prev_node  <span class="comment">// 设置前驱节点</span></span><br><span class="line">        <span class="comment">// 自旋等待前驱节点释放锁</span></span><br><span class="line">        <span class="keyword">while</span> prev_node.status == <span class="literal">true</span>:</span><br><span class="line">            <span class="comment">// 等待...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>unlock 方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">unlock</span><span class="params">()</span>:</span><br><span class="line">    current_node = getCurrentNode()  <span class="comment">// 获取当前线程的节点</span></span><br><span class="line">    <span class="keyword">if</span> current_node.next == <span class="literal">null</span>:</span><br><span class="line">        <span class="comment">// 如果没有后继节点，尝试将尾指针置空（释放队列）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="title function_">CASCompareAndSet</span><span class="params">(tail, current_node, <span class="literal">null</span>)</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">// 唤醒后继节点</span></span><br><span class="line">        current_node.next.status = <span class="literal">true</span>  <span class="comment">// 标记后继节点可以获取锁</span></span><br><span class="line">    current_node.status = <span class="literal">true</span>  <span class="comment">// 当前线程释放锁</span></span><br></pre></td></tr></table></figure>

<h3 id="synchronized-的实现原理"><a href="#synchronized-的实现原理" class="headerlink" title="synchronized 的实现原理"></a>synchronized 的实现原理</h3><p><code>synchronized</code> 的实现原理主要依赖于 <strong>Monitor（监视器）机制</strong> 和 <strong>JVM 的锁管理</strong>，具体如下：</p>
<ol>
<li><strong>基于 Monitor 的同步机制</strong><br>在 JVM 中，每个对象都关联一个 Monitor 对象。当线程执行 <code>synchronized</code> 代码块或方法时，会通过 <code>monitorenter</code> 和 <code>monitorexit</code> 指令尝试获取或释放 Monitor 锁。若锁已被其他线程持有，则当前线程会被阻塞，直到锁被释放 。</li>
<li><strong>锁的获取与释放</strong>  <ul>
<li><strong>代码块同步</strong>：通过 <code>monitorenter</code> 指令标记同步代码块的起始，线程进入时需获取锁；执行完成后通过 <code>monitorexit</code> 释放锁。</li>
<li><strong>方法同步</strong>：通过方法访问标志中的 <code>ACC_SYNCHRONIZED</code> 标志实现，线程调用方法时自动尝试获取锁，方法执行结束或抛出异常时释放锁 。</li>
</ul>
</li>
<li><strong>保证并发安全的三大特性</strong>  <ul>
<li><strong>原子性</strong>：通过锁机制确保同一时间只有一个线程执行同步代码，避免数据竞争 。</li>
<li><strong>可见性</strong>：锁的获取和释放隐含内存屏障操作，确保线程对共享变量的修改对其他线程可见 。</li>
<li><strong>有序性</strong>：通过限制指令重排序，保证代码按预期顺序执行 。</li>
</ul>
</li>
<li><strong>锁的优化（JDK 6 及以后）</strong><br>JDK 6 引入了 <strong>自适应自旋锁</strong>，即自旋次数不再固定，而是根据前一次在同一锁上的自旋效果动态调整。例如，若某锁的自旋成功率较低，则减少后续自旋次数，从而减少 CPU 资源浪费 。</li>
<li><strong>底层实现的互斥性</strong><br><code>synchronized</code> 是由 JVM 直接支持的互斥同步机制，其核心是通过操作系统层面的互斥锁（如 pthread_mutex）实现线程阻塞与唤醒 。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SynchronizedDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::run);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(demo.i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对应字节码</span><br><span class="line"><span class="comment">// class version 65.0 (65)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>/oceanbase/oms/SynchronizedDemo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compiled from: SynchronizedDemo.java</span></span><br><span class="line">    <span class="comment">// access flags 0x19</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> INNERCLASS java/lang/invoke/MethodHandles$Lookup java/lang/invoke/MethodHandles Lookup</span><br><span class="line"></span><br><span class="line">    <span class="comment">// access flags 0x2</span></span><br><span class="line">    <span class="keyword">private</span> I i</span><br><span class="line"></span><br><span class="line">    <span class="comment">// access flags 0x1</span></span><br><span class="line">    <span class="keyword">public</span> &lt;init&gt;()V</span><br><span class="line">    L0</span><br><span class="line">    LINENUMBER <span class="number">3</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">    L1</span><br><span class="line">    LINENUMBER <span class="number">4</span> L1</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    ICONST_0</span><br><span class="line">    PUTFIELD com/oceanbase/oms/SynchronizedDemo.i : I</span><br><span class="line">    RETURN</span><br><span class="line">    L2</span><br><span class="line">    LOCALVARIABLE <span class="built_in">this</span> Lcom/oceanbase/oms/SynchronizedDemo; L0 L2 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// access flags 0x9</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">([Ljava/lang/String;)</span>V <span class="keyword">throws</span> java/lang/Exception </span><br><span class="line">    L0</span><br><span class="line">    LINENUMBER <span class="number">7</span> L0</span><br><span class="line">    NEW com/oceanbase/oms/SynchronizedDemo</span><br><span class="line">    DUP</span><br><span class="line">    INVOKESPECIAL com/oceanbase/oms/SynchronizedDemo.&lt;init&gt; ()V</span><br><span class="line">    ASTORE <span class="number">1</span></span><br><span class="line">    L1</span><br><span class="line">    LINENUMBER <span class="number">8</span> L1</span><br><span class="line">    ICONST_0</span><br><span class="line">    ISTORE <span class="number">2</span></span><br><span class="line">    L2</span><br><span class="line">    FRAME APPEND [com/oceanbase/oms/SynchronizedDemo I]</span><br><span class="line">    ILOAD <span class="number">2</span></span><br><span class="line">    ICONST_5</span><br><span class="line">    IF_ICMPGE L3</span><br><span class="line">    L4</span><br><span class="line">    LINENUMBER <span class="number">9</span> L4</span><br><span class="line">    NEW java/lang/Thread</span><br><span class="line">    DUP</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    DUP</span><br><span class="line">    INVOKESTATIC java/util/Objects.requireNonNull (Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">    POP</span><br><span class="line">    INVOKEDYNAMIC <span class="title function_">run</span><span class="params">(Lcom/oceanbase/oms/SynchronizedDemo;)</span>Ljava/lang/Runnable; [</span><br><span class="line">    <span class="comment">// handle kind 0x6 : INVOKESTATIC</span></span><br><span class="line">    java/lang/invoke/LambdaMetafactory.metafactory(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    <span class="comment">// arguments:</span></span><br><span class="line">    ()V, </span><br><span class="line">    <span class="comment">// handle kind 0x5 : INVOKEVIRTUAL</span></span><br><span class="line">    com/oceanbase/oms/SynchronizedDemo.run()V, </span><br><span class="line">    ()V</span><br><span class="line">    ]</span><br><span class="line">    INVOKESPECIAL java/lang/Thread.&lt;init&gt; (Ljava/lang/Runnable;)V</span><br><span class="line">    ASTORE <span class="number">3</span></span><br><span class="line">    L5</span><br><span class="line">    LINENUMBER <span class="number">10</span> L5</span><br><span class="line">    ALOAD <span class="number">3</span></span><br><span class="line">    INVOKEVIRTUAL java/lang/Thread.start ()V</span><br><span class="line">    L6</span><br><span class="line">    LINENUMBER <span class="number">8</span> L6</span><br><span class="line">    IINC <span class="number">2</span> <span class="number">1</span></span><br><span class="line">    GOTO L2</span><br><span class="line">    L3</span><br><span class="line">    LINENUMBER <span class="number">12</span> L3</span><br><span class="line">    FRAME CHOP <span class="number">1</span></span><br><span class="line">    LDC <span class="number">1000</span></span><br><span class="line">    INVOKESTATIC java/lang/Thread.sleep (J)V</span><br><span class="line">    L7</span><br><span class="line">    LINENUMBER <span class="number">13</span> L7</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    GETFIELD com/oceanbase/oms/SynchronizedDemo.i : I</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (I)V</span><br><span class="line">    L8</span><br><span class="line">    LINENUMBER <span class="number">14</span> L8</span><br><span class="line">    RETURN</span><br><span class="line">    L9</span><br><span class="line">    LOCALVARIABLE t Ljava/lang/Thread; L5 L6 <span class="number">3</span></span><br><span class="line">    LOCALVARIABLE i I L2 L3 <span class="number">2</span></span><br><span class="line">    LOCALVARIABLE args [Ljava/lang/String; L0 L9 <span class="number">0</span></span><br><span class="line">    LOCALVARIABLE demo Lcom/oceanbase/oms/SynchronizedDemo; L1 L9 <span class="number">1</span></span><br><span class="line">    MAXSTACK = <span class="number">4</span></span><br><span class="line">    MAXLOCALS = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">run</span><span class="params">()</span>V</span><br><span class="line">    TRYCATCHBLOCK L0 L1 L2 <span class="literal">null</span></span><br><span class="line">    TRYCATCHBLOCK L2 L3 L2 <span class="literal">null</span></span><br><span class="line">   L4</span><br><span class="line">    LINENUMBER <span class="number">17</span> L4</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    DUP</span><br><span class="line">    ASTORE <span class="number">1</span></span><br><span class="line">    MONITORENTER</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">18</span> L0</span><br><span class="line">    ICONST_0</span><br><span class="line">    ISTORE <span class="number">2</span></span><br><span class="line">   L5</span><br><span class="line">   FRAME APPEND [java/lang/Object I]</span><br><span class="line">    ILOAD <span class="number">2</span></span><br><span class="line">    BIPUSH <span class="number">100</span></span><br><span class="line">    IF_ICMPGE L6</span><br><span class="line">   L7</span><br><span class="line">    LINENUMBER <span class="number">19</span> L7</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    DUP</span><br><span class="line">    GETFIELD com/oceanbase/oms/SynchronizedDemo.i : I</span><br><span class="line">    ICONST_1</span><br><span class="line">    IADD</span><br><span class="line">    PUTFIELD com/oceanbase/oms/SynchronizedDemo.i : I</span><br><span class="line">   L8</span><br><span class="line">    LINENUMBER <span class="number">18</span> L8</span><br><span class="line">    IINC <span class="number">2</span> <span class="number">1</span></span><br><span class="line">    GOTO L5</span><br><span class="line">   L6</span><br><span class="line">    LINENUMBER <span class="number">21</span> L6</span><br><span class="line">   FRAME CHOP <span class="number">1</span></span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    MONITOREXIT</span><br><span class="line">   L1</span><br><span class="line">    GOTO L9</span><br><span class="line">   L2</span><br><span class="line">   FRAME SAME1 java/lang/Throwable</span><br><span class="line">    ASTORE <span class="number">3</span></span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    MONITOREXIT</span><br><span class="line">   L3</span><br><span class="line">    ALOAD <span class="number">3</span></span><br><span class="line">    ATHROW</span><br><span class="line">   L9</span><br><span class="line">    LINENUMBER <span class="number">22</span> L9</span><br><span class="line">   FRAME CHOP <span class="number">1</span></span><br><span class="line">    RETURN</span><br><span class="line">   L10</span><br><span class="line">    LOCALVARIABLE j I L5 L6 <span class="number">2</span></span><br><span class="line">    LOCALVARIABLE <span class="built_in">this</span> Lcom/oceanbase/oms/SynchronizedDemo; L4 L10 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">3</span></span><br><span class="line">    MAXLOCALS = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 MONITORENTER &#x2F; MONITOREXIT 构成了互斥对</p>
<p><img src="/images/java/concurrency-lock-1.png" alt="image-1"></p>
<h4 id="Monitor-对象的介绍"><a href="#Monitor-对象的介绍" class="headerlink" title="Monitor 对象的介绍"></a>Monitor 对象的介绍</h4><p>JVM 中的 <strong>Monitor 对象</strong> 是 Java 实现线程同步的核心机制之一，它与对象（或类）紧密关联，用于管理线程对共享资源的互斥访问和协作通信。以下是其核心要点：</p>
<p><strong>1. Monitor 的本质与作用</strong></p>
<ul>
<li><strong>定义</strong>：Monitor 是 JVM 中每个对象或类在逻辑上关联的一个监视器对象，负责管理线程的同步与协作 。  </li>
<li><strong>功能</strong>：  <ul>
<li><strong>互斥性</strong>：确保同一时间只有一个线程能持有锁（即 Monitor 的 <code>owner</code>），其他线程需等待 。  </li>
<li><strong>线程协作</strong>：通过 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 等方法实现线程间的条件等待和唤醒 。</li>
</ul>
</li>
</ul>
<p><strong>2. Monitor 的实现结构</strong></p>
<p>在 HotSpot 虚拟机中，Monitor 基于 C++ 的 <code>ObjectMonitor</code> 类实现，其核心成员包括：  </p>
<ul>
<li><code>_owner</code>：指向当前持有 Monitor 的线程 。  </li>
<li><code>_EntryList</code>：存储等待获取锁的线程队列 。  </li>
<li><code>_WaitSet</code>：存储调用 <code>wait()</code> 后进入等待状态的线程队列 。  </li>
<li><code>_count</code>：记录锁的重入次数 。</li>
</ul>
<p>此外，Monitor 的状态通过 <strong>Mark Word</strong>（对象头的一部分）与实际数据结构关联。Mark Word 中存储了指向 Monitor 的指针（当锁升级为重量级锁时）。</p>
<p><strong>3. Monitor 与 <strong><code>synchronized</code></strong> 的关系</strong></p>
<ul>
<li><strong>锁的获取</strong>：当线程执行 <code>synchronized</code> 代码块或方法时，JVM 会通过 <code>monitorenter</code> 指令尝试获取对象的 Monitor。若 Monitor 未被占用，则线程成为 <code>owner</code>；若已被占用，则线程进入 <code>_EntryList</code> 等待 。  </li>
<li><strong>锁的释放</strong>：线程执行完同步代码块或方法后，通过 <code>monitorexit</code> 指令释放 Monitor，并唤醒 <code>_EntryList</code> 中的等待线程 。</li>
</ul>
<p><strong>4. Monitor 的生命周期与优化</strong></p>
<ul>
<li><strong>存储位置</strong>：Monitor 对象本身存储在 JVM 的非堆内存中（如 C++ 堆），而对象头的 Mark Word 会指向 Monitor 的地址（仅在重量级锁状态下）。  </li>
<li><strong>线程本地分配</strong>：每个线程维护两个 <code>ObjectMonitor</code> 列表（<code>free</code> 和 <code>used</code>），优先从线程本地分配，减少全局竞争 。  </li>
<li><strong>锁优化</strong>：JDK 6 后引入偏向锁、轻量级锁等优化，减少 Monitor 的直接使用，提升性能 。</li>
</ul>
<p><strong>5. Monitor 的应用场景</strong></p>
<ul>
<li><strong>重量级锁</strong>：当多个线程竞争锁时，Monitor 升级为重量级锁，依赖操作系统互斥量（如 pthread_mutex）实现阻塞与唤醒 。  </li>
<li><strong>线程协作</strong>：通过 <code>wait()</code> 和 <code>notify()</code> 在 Monitor 的 <code>_WaitSet</code> 和 <code>_EntryList</code> 之间转移线程，实现生产者-消费者等模式 。</li>
</ul>
<h3 id="ReentrantLock-的实现"><a href="#ReentrantLock-的实现" class="headerlink" title="ReentrantLock 的实现"></a>ReentrantLock 的实现</h3><ol>
<li>**可重入性 **：同一个线程可以多次获取同一把锁，避免死锁。例如，一个线程在持有锁的情况下再次进入同步代码块时无需重新竞争锁 。</li>
<li>**支持公平与非公平模式 **：<ul>
<li>**公平模式 **：线程按照请求锁的顺序获取锁，避免“插队”现象，但可能降低吞吐量。</li>
<li>**非公平模式 **：允许线程“插队”获取锁（如刚释放锁的线程可能立即重新获取），提高性能但可能导致某些线程饥饿 。</li>
</ul>
</li>
<li>**灵活的锁控制 **：提供 <code>**&gt;tryLock()**</code>（尝试获取锁）、<code>**&gt;tryLock(long timeout, TimeUnit unit)**</code>（带超时的尝试获取锁）、<code>**&gt;lockInterruptibly()**</code>（可中断的锁获取）等方法，增强对锁行为的细粒度控制</li>
</ol>
<p>典型使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 必须在 finally 块中释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心实现说明</strong></p>
<p>依托于 AQS 实现，其中内部类 <code>Sync</code> 集成了 AQS，利用 AQS 的状态管理（state） 、线程队列（CLH） 和 CAS 机制实现锁机制。</p>
<p><code>Sync</code>存在 <code>FairSync</code>与 <code>NonfairSync</code>两类实现，即公平锁与非公平锁。</p>
<p><strong>一、获取锁</strong></p>
<ol>
<li><strong>公平锁</strong>  <ul>
<li><strong>检查等待队列</strong>：线程尝试获取锁时，会先检查 AQS 阻塞队列中是否有等待线程(<code>hasQueuedPredecessors()</code>)。如果存在等待线程（即当前线程不是队列的第一个节点），则当前线程获取锁失败，并加入阻塞队列尾部等待(<code>**acquireQueued(addWaiter(Node.EXCLUSIVE), arg))**</code>) 。  </li>
<li><strong>CAS 修改状态</strong>：若队列为空或当前线程位于队列头部，则通过 CAS 操作尝试将 <code>state</code> 从 0 修改为 1。成功则成为锁的持有者；失败则继续等待 。</li>
</ul>
</li>
<li><strong>非公平锁</strong>  <ul>
<li><strong>直接尝试 CAS</strong>：线程不检查等待队列，直接通过 CAS 操作尝试获取锁（即使队列中有等待线程）。若 CAS 成功，则成为锁的持有者 。  </li>
<li><strong>失败后入队</strong>：若 CAS 失败，则检查当前线程是否已持有锁（可重入性）。若未持有，则加入 AQS 阻塞队列等待 。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>二、释放锁</strong></p>
<p>公平锁与非公平锁的释放流程完全一致，均基于 AQS 的通用机制：  </p>
<ol>
<li><strong>减少同步状态</strong>：线程调用 <code>unlock()</code> 方法时，<code>state</code> 值减 1（若 <code>state &gt; 0</code>）。  </li>
<li><strong>完全释放锁</strong>：当 <code>state</code> 减至 0 时，锁被完全释放，AQS 队列中的头节点（等待最久的线程）被唤醒，重新尝试获取锁 。  </li>
<li><strong>唤醒后续线程</strong>：释放锁后，通过 <code>unparkSuccessor()</code> 方法唤醒阻塞队列中的下一个线程，确保锁的公平传递 。</li>
</ol>
<p><strong>核心差异总结</strong></p>
<table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>公平锁</strong></th>
<th><strong>非公平锁</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>获取锁</strong></td>
<td>严格按队列顺序获取，避免“插队”</td>
<td>先尝试“插队”获取锁，失败后再入队</td>
</tr>
<tr>
<td><strong>释放锁</strong></td>
<td>与非公平锁完全一致</td>
<td>与公平锁完全一致</td>
</tr>
</tbody></table>
<h3 id="关键实现原理"><a href="#关键实现原理" class="headerlink" title="关键实现原理"></a><strong>关键实现原理</strong></h3><ul>
<li><strong>公平锁</strong>：通过 <code>hasQueuedPredecessors()</code> 方法检查队列中是否有前驱节点，确保“先来先服务” 。  </li>
<li><strong>非公平锁</strong>：通过 <code>nonfairTryAcquire()</code> 方法直接尝试 CAS，允许新线程“插队”获取锁 。</li>
</ul>
<p>通过上述机制，公平锁保证了线程获取锁的顺序性，而非公平锁通过牺牲公平性提升了性能 。</p>
<h3 id="ReentrantReadWriteLock-的实现"><a href="#ReentrantReadWriteLock-的实现" class="headerlink" title="ReentrantReadWriteLock 的实现"></a>ReentrantReadWriteLock 的实现</h3><p>ReentrantReadWriteLock 是 Java 中用于管理读写并发访问的可重入锁，其核心用途在于 <strong>允许多个读线程同时访问共享资源，而写线程独占资源</strong>，从而优化读多写少场景下的性能 。它适用于缓存、共享数据结构等需要高效读取的场景 。</p>
<p><strong>实现原理与核心思想</strong></p>
<ol>
<li><strong>基于 AQS 的状态设计</strong><br>ReentrantReadWriteLock 通过内部类 <code>Sync</code> 继承 AQS（AbstractQueuedSynchronizer），利用 AQS 的同步状态（state）管理读写锁的获取与释放。其核心思想是通过 <strong>位运算分割 state</strong>：高 16 位表示读锁的持有次数<strong>（读状态）</strong>，低 16 位表示写锁的持有次数<strong>（写状态）</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read vs write count extraction constants and functions.</span></span><br><span class="line"><span class="comment"> * Lock state is logically divided into two unsigned shorts:</span></span><br><span class="line"><span class="comment"> * The lower one representing the exclusive (writer) lock hold count,</span></span><br><span class="line"><span class="comment"> * and the upper the shared (reader) hold count.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_UNIT</span>    <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span>      <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the number of shared holds represented in count. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sharedCount</span><span class="params">(<span class="type">int</span> c)</span>    &#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">/** Returns the number of exclusive holds represented in count. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclusiveCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>公平性与非公平性</strong><br>支持公平锁和非公平锁，通过构造函数传入 <code>fair</code> 参数控制。默认为非公平模式，以提升吞吐量；公平模式则保证等待时间最长的线程优先获取锁 。</li>
<li><strong>读写锁的互斥规则</strong>  <ul>
<li><strong>读锁共享</strong>：多个线程可同时获取读锁，但写锁未被占用时才允许 。  </li>
<li><strong>写锁独占</strong>：写锁被占用时，其他读写线程均需等待 。  </li>
<li><strong>锁降级</strong>：写锁可降级为读锁，但读锁不能升级为写锁 。</li>
</ul>
</li>
<li><strong>可重入性</strong><br>同一线程可多次获取读锁或写锁，通过记录持有次数实现重入，并在释放时递减计数 。</li>
</ol>
<p><strong>主要实现方法</strong></p>
<ol>
<li><code>**tryAcquireShared**</code>** 方法**</li>
</ol>
<p>该方法用于尝试获取读锁（共享锁），其核心流程如下：</p>
<ul>
<li><strong>检查写锁状态</strong>：如果当前存在写锁且持有者不是当前线程，则直接返回 <code>-1</code>（获取失败），避免读写冲突 。</li>
<li><strong>读锁计数更新</strong>：通过位运算获取当前读锁的持有次数（<code>state</code> 高 16 位），并尝试增加 1。若超过最大重入次数（<code>65535</code>），则抛出异常 。</li>
<li><strong>CAS 更新状态</strong>：使用原子操作 <code>compareAndSetState</code> 更新 <code>state</code> 的高 16 位（读锁计数），确保线程安全 。</li>
<li><strong>成功获取读锁</strong>：若 CAS 成功，则记录当前线程的读锁重入次数（通过 <code>ThreadLocal</code> 管理），并返回 <code>1</code>，表示获取共享锁成功 。</li>
<li><strong>失败处理</strong>：若因写锁占用或 CAS 冲突导致失败，返回负值，线程需进入 AQS 队列等待 。（参考下文 <code>fullTryAcquireShared</code>方法）</li>
</ul>
<ol start="2">
<li><code>**fullTryAcquireShared**</code></li>
</ol>
<p>fullTryAcquireShared 方法主要用于 在 tryAcquireShared 尝试获取读锁失败后，<strong>进行更完整的重试逻辑。</strong></p>
<pre><code>1. **循环尝试获取锁**
</code></pre>
<p>fullTryAcquireShared 通过 自旋循环 不断尝试获取读锁，直到以下情况之一发生：</p>
<ul>
<li>成功更新 state 的高 16 位（读锁计数）。</li>
<li>因写锁占用、公平性规则或线程中断需退出循环 <ol start="2">
<li><strong>检查写锁状态</strong></li>
</ol>
</li>
</ul>
<p>如果当前存在写锁<code>（exclusiveCount(c) != 0）</code>且持有者不是当前线程，则直接返回 -1，线程需进入等待队列。这确保了<strong>写锁独占</strong>的原则，避免读写冲突 。</p>
<pre><code>3. **公平性判断**`**（readerShouldBlock()）**`
</code></pre>
<p>在公平模式下，调用 readerShouldBlock() 检查是否需要阻塞。例如：</p>
<ul>
<li>队列中存在更早等待的线程（写锁优先或公平锁规则）。</li>
<li>非公平模式下，仅检查是否有写锁等待（避免写锁饥饿）。</li>
</ul>
<p>若需阻塞，则线程需加入 AQS 队列等待 。</p>
<pre><code>4. **读锁重入次数上限**
</code></pre>
<p>若当前线程的读锁重入次数超过最大值（65535），抛出 Error（如 ErrorReadCounterOverflow）。因为 state 的高 16 位最多表示 2^16 - 1 &#x3D; 65535 次重入，避免状态溢出 。</p>
<pre><code>5. **CAS 更新读锁计数**
</code></pre>
<p>通过 <code>compareAndSetState(c, c + SHARED_UNIT)</code> 尝试原子更新 state。若 CAS 成功，记录当前线程的读锁重入次数（通过 HoldCounter 或 ThreadLocal 管理），并返回成功状态。</p>
<ol start="3">
<li><strong><code>tryReleaseShared**</code> 方法</strong></li>
</ol>
<p>该方法用于释放读锁，流程如下：</p>
<ul>
<li><strong>递减读锁计数</strong>：从 <code>state</code> 的高 16 位读取当前读锁次数，减 1 后重新计算新值 。</li>
<li><strong>CAS 更新状态</strong>：使用原子操作更新 <code>state</code>，确保读锁计数的线程安全 。</li>
<li><strong>检查是否完全释放</strong>：若读锁计数减至 0（即所有读锁释放），则唤醒 AQS 队列中等待的写锁线程（若有）。</li>
<li><strong>返回值</strong>：始终返回 <code>true</code>，表示共享锁释放完成 。</li>
</ul>
<ol start="4">
<li><strong><code>tryReadLock</code> 方法</strong></li>
</ol>
<p>该方法用于非阻塞地尝试获取读锁（类似 <code>tryLock()</code>），流程如下：</p>
<ul>
<li><strong>快速尝试获取</strong>：直接检查写锁状态和当前线程是否已持有写锁（允许锁降级），并尝试通过 CAS 更新读锁计数 。</li>
<li><strong>失败处理</strong>：若写锁被其他线程占用或 CAS 冲突，则立即返回失败，不进入等待队列 。</li>
<li><strong>与 <strong><code>tryAcquireShared</code></strong> 的对比</strong>：<code>tryReadLock</code> 是轻量级的单次尝试，而 <code>tryAcquireShared</code> 可能涉及多次重试和队列阻塞 。</li>
</ul>
<ol start="5">
<li><code>**&gt;tryAcquire**</code>** 方法（写锁的获取）**</li>
</ol>
<p>该方法用于尝试获取写锁（独占锁），核心流程如下：</p>
<ul>
<li>**检查读锁状态 **：如果当前存在读锁（<code>**&gt;sharedCount != 0**</code>），则直接返回 <code>**&gt;false**</code>（读写冲突）。</li>
<li>**检查写锁持有者 **：若写锁已被其他线程持有（<code>**&gt;exclusiveCount != 0**</code> 且持有者不是当前线程），返回 <code>**&gt;false**</code>。</li>
<li>**重入处理 **：若当前线程已持有写锁，则递增写锁计数（<code>**&gt;state + 1**</code>）。</li>
<li>**CAS 更新状态 **：尝试通过 <code>**&gt;compareAndSetState**</code> 原子更新 <code>**&gt;state**</code> 的低 16 位（写锁计数）。若成功，设置当前线程为写锁持有者。</li>
<li>**公平性判断 **：在公平模式下，若等待队列中有其他线程等待，则当前线程需进入队列并阻塞。</li>
</ul>
<ol start="6">
<li><strong><code>tryRelease**</code> 方法（写锁的释放）</strong></li>
</ol>
<p>该方法用于释放写锁，流程如下：</p>
<ul>
<li>**递减写锁计数 **：从 <code>**&gt;state**</code> 的低 16 位读取当前写锁次数，减 1 后计算新值。</li>
<li>**检查是否完全释放 **：若写锁计数减至 0（即所有重入释放完成），则清空写锁持有者标识。</li>
<li>**CAS 更新状态 **：通过原子操作更新 <code>**&gt;state**</code>，确保线程安全。</li>
<li>**唤醒等待线程 **：若写锁完全释放，调用 <code>**&gt;unparkSuccessor**</code> 唤醒 AQS 队列中等待的读锁或写锁线程 。</li>
</ul>
<ol start="7">
<li><strong><code>tryWriteLock**</code> 方法（非阻塞尝试获取写锁）</strong></li>
</ol>
<p>该方法用于非阻塞地尝试获取写锁（类似 **<code>tryLock()</code>**），流程如下：</p>
<ul>
<li>**快速检查 **：若当前存在读锁或写锁（且持有者不是当前线程），直接返回失败。</li>
<li>**CAS 尝试获取 **：尝试通过 <code>compareAndSetState</code> 原子设置 <code>state</code> 的低 16 位为 1（初始写锁计数）。若成功，设置当前线程为写锁持有者。</li>
<li>**失败处理 **：若因竞争或锁占用导致 CAS 失败，立即返回 <code>false</code>，不进入等待队列。</li>
<li>**与 <code>tryAcquire**</code> 的对比 **：<code>tryWriteLock</code> 是轻量级的单次尝试，而 <code>tryAcquire</code> 可能涉及公平性判断和队列阻塞。</li>
</ul>
<h3 id="StampedLock-的实现"><a href="#StampedLock-的实现" class="headerlink" title="StampedLock 的实现****"></a>StampedLock 的实现****</h3><p>使用范例：如何实现一个线程安全的二维点（Point）类，支持并发读写操作，并体现 乐观读 和 锁升级 的典型场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写锁：移动点到指定坐标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> deltaX, <span class="type">double</span> deltaY)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();  <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamp);  <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乐观读：计算点到原点的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distanceToOrigin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();  <span class="comment">// 获取乐观读锁</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentX</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">double</span> <span class="variable">currentY</span> <span class="operator">=</span> y;</span><br><span class="line">        <span class="comment">// 验证乐观读期间是否有写操作</span></span><br><span class="line">        <span class="keyword">if</span> (!lock.validate(stamp)) &#123;</span><br><span class="line">            <span class="comment">// 若有写操作，升级为悲观读锁</span></span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlockRead(stamp);  <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁升级：如果点在原点，则移动到指定坐标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveIfAtOrigin</span><span class="params">(<span class="type">double</span> newX, <span class="type">double</span> newY)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();  <span class="comment">// 尝试乐观读</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentX</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">double</span> <span class="variable">currentY</span> <span class="operator">=</span> y;</span><br><span class="line">        <span class="keyword">if</span> (currentX == <span class="number">0</span> &amp;&amp; currentY == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 需要升级为写锁</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">writeStamp</span> <span class="operator">=</span> lock.convertToWriteLock(stamp);  <span class="comment">// 升级为写锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 二次检查避免其他线程已修改</span></span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                    x = newX;</span><br><span class="line">                    y = newY;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlockWrite(writeStamp);  <span class="comment">// 释放写锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前坐标（用于测试）</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCurrentPosition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Point(&quot;</span> + x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong></p>
<ol>
<li><strong>高并发读多写少的场景</strong><br>StampedLock 的核心优势在于 <strong>乐观读机制</strong>，允许多个线程在无写操作时并发读取共享数据，适用于缓存系统、频繁读取的共享数据结构等场景 。</li>
<li><strong>需避免写线程饥饿的场景</strong><br>StampedLock 允许写线程在公平模式下优先获取锁，解决了传统读写锁中写线程可能因读线程过多而饥饿的问题 。</li>
<li><strong>无需重入锁的场景</strong><br>StampedLock 是非重入锁，若线程不会在持有锁的代码块中再次尝试获取锁，则可使用它 。</li>
<li><strong>需要锁降级或升级的场景</strong><br>支持将乐观读锁升级为写锁（需显式处理），适用于 <code>if-then-update</code> 的原子操作场景（如先读取数据，若条件不满足则写入更新）。以下是 <strong>StampedLock</strong> 与 <strong>ReentrantReadWriteLock</strong> 的优劣势对比表格：</li>
</ol>
<p><strong>与 ReentrantReadWriteLock 的比较</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>StampedLock</strong></th>
<th><strong>ReentrantReadWriteLock</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>优势</strong></td>
<td>1. <strong>高性能</strong>：基于乐观读机制，减少锁竞争，显著提升读多写少场景的吞吐量 。   2. <strong>写线程优先</strong>：支持公平模式，避免写线程饥饿 。   3. <strong>轻量级</strong>：CAS 操作优化，降低资源消耗 。</td>
<td>1. <strong>可重入性</strong>：支持线程多次获取读写锁，简化代码逻辑 。   2. <strong>成熟稳定</strong>：广泛应用于传统并发场景，兼容性强 。   3. <strong>精确控制</strong>：适用于需精细管理缓存或共享数据的场景 。</td>
</tr>
<tr>
<td><strong>劣势</strong></td>
<td>1. <strong>非重入性</strong>：同一线程多次获取锁会导致死锁风险 。   2. <strong>API 复杂</strong>：需显式管理 <code>stamp</code>，增加使用难度 。   3. <strong>不支持条件变量</strong>：无法通过 <code>Condition</code> 实现线程通信 。</td>
<td>1. <strong>性能瓶颈</strong>：读写互斥，读多写少场景下性能低于 StampedLock 。   2. <strong>写线程饥饿</strong>：高并发下写线程可能长期等待 。   3. <strong>锁降级限制</strong>：需显式处理读写锁转换，逻辑复杂 。</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>高并发读多写少、需高性能吞吐（如缓存系统、共享数据结构） 。</td>
<td>需要可重入性、精确控制缓存或低频写操作的场景（如配置管理、少量更新的共享资源） 。</td>
</tr>
<tr>
<td><strong>典型改进点</strong></td>
<td>通过乐观读避免线程阻塞，支持锁升级&#x2F;降级 。</td>
<td>提供读写分离，但读写互斥导致性能限制 。</td>
</tr>
</tbody></table>
<ul>
<li><strong>StampedLock</strong> 更适合 <strong>高性能、读多写少</strong> 的场景，但需容忍其 <strong>非重入性</strong> 和 <strong>复杂 API</strong> 。</li>
<li><strong>ReentrantReadWriteLock</strong> 更适合 <strong>需要可重入性</strong> 和 <strong>简单控制</strong> 的场景，但需注意写线程饥饿问题 。</li>
</ul>
<p><strong>实现原理</strong></p>
<ol>
<li><strong>状态管理</strong><br>StampedLock 的状态（<code>state</code>）由 <strong>版本号（前 48 位）</strong> 和 <strong>模式（后 16 位）</strong> 组成：<ul>
<li><strong>模式位</strong>：表示当前锁的状态（0 表示无锁，1 表示写锁，2 表示悲观读锁，3 表示乐观读锁）。</li>
<li><strong>版本号</strong>：用于标识数据版本，每次写操作会递增版本号，确保乐观读的线程能检测到数据变化 。</li>
</ul>
</li>
<li><strong>乐观读机制</strong>  <ul>
<li><strong>读操作</strong>：通过 <code>tryOptimisticRead()</code> 获取当前版本号（stamp），读取数据后通过 <code>validate(stamp)</code> 检查版本号是否变化。若未变化，说明读期间无写操作；若变化，需升级为悲观读锁或重试 。</li>
<li><strong>写操作</strong>：通过 <code>writeLock()</code> 获取独占锁，修改数据后更新版本号，确保其他线程能感知到变更 。</li>
</ul>
</li>
<li><strong>锁升级与降级</strong>  <ul>
<li><strong>升级</strong>：将乐观读锁通过 <code>validate()</code> 和 <code>writeLock()</code> 升级为写锁，但需重新验证数据一致性 。</li>
<li><strong>降级</strong>：持有写锁的线程可通过 <code>readLock()</code> 降级为悲观读锁，避免重复竞争 。</li>
</ul>
</li>
<li><strong>等待队列管理</strong><br>基于 AQS 实现线程排队，写锁优先级高于读锁。在公平模式下，线程按 FIFO 顺序获取锁；在非公平模式下，允许写线程插队 。</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1690060">AQS基础——多图详解CLH锁的原理与实现</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1829985">解决线程饥饿的神器StampedLock，你值得拥有！</a></li>
<li>《Java 并发编程深度解析与实战》</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/04/12/FLIP-144-Native-Kubernetes-HA-for-Flink/" rel="prev" title="FLIP-144: Native Kubernetes HA for Flink">
                  <i class="fa fa-angle-left"></i> FLIP-144: Native Kubernetes HA for Flink
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/06/03/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B/" rel="next" title="Java并发基础-线程">
                  Java并发基础-线程 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">刘冰鉴</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
